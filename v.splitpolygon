#!/usr/bin/env python
# -*- coding: utf-8  -*-
#
############################################################################
#
# MODULE:      v.splitpolygon
# AUTHOR(S):   Dmitry Kolesov (kolesov.dm@gmail.com);
#
# PURPOSE:     Split area by user defined line.
#
# COPYRIGHT:   (C) 2014 Dmitry Kolesov / NextGIS company
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
############################################################################

#%Module
#% description: Split area by user defined line (line MUST intersect the whole area).
#%End
#%option
#% key: input
#% type: string
#% description: name of the input vector map
#% required : yes
#% multiple: no
#%end
#%option
#% key: line
#% type: string
#% description: name of the line map
#% required : yes
#% multiple: no
#%end
#%option
#% key: output
#% type: string
#% description: name of the output vector map
#% required : yes
#% multiple: no
#%end
#%option
#% key: tol
#% type: double
#% description: tolerance
#% required : no
#% multiple: no
#%end
#%flag
#% key: t
#% description: Do not create attribute table
#%end

import os, sys

if "GISBASE" not in os.environ:
    print "You must be in GRASS GIS to run this program."
    sys.exit(1)

import grass.script as grass
import csv


def main(options, flags):
    t_flag = flags['t']
    in_map = options['input']
    line = options['line']
    out_map = options['output']
    tol = options['tol']
    if not tol:
        tol = 0.00001
    else:
        tol = float(tol)

    tmp_map = 'buffer_tmp_%d' % os.getpid()
    try:
        grass.run_command('v.buffer', input=line, output=tmp_map, distance=tol, quiet=True)
        grass.run_command('v.overlay',
            ainput=in_map, binput=tmp_map, output=out_map, operator='not',
            flags = 't',
            overwrite=True, quiet=True
        )
    finally:
        grass.run_command('g.remove', vect=tmp_map, quiet=True)

    # Copy attribute table
    if not t_flag:
        # Get category of the initial polygon
        p = grass.pipe_command('v.category', input=in_map, option='print')
        cat = p.stdout.readline().strip()
        p.wait()

        # Copy table
        p = grass.pipe_command('v.db.connect', map=in_map, flags='g')
        conn_info = p.stdout.readline()
        p.wait()
        layer, table, field, db, driver = conn_info.split()
        grass.run_command(
             'db.copy',
             from_driver=driver, to_driver=driver,
             from_table=table, to_table=out_map,
             from_database=db, to_database=db,
             where="%s=%s" % (field, cat),
             quiet=True
        )
        grass.run_command('v.db.connect',
            map=out_map, driver=driver, database=db, key=field, layer=1, table=out_map,
            quiet=True
        )

        # Update attributes to conform the new categories of out_map
        p = grass.pipe_command('v.db.select', map=out_map, where="%s=%s" % (field, cat))
        reader = csv.DictReader(p.stdout, delimiter='|')
        row = reader.next()
        p.wait()
        fields = row.keys()

        sql = "DELETE FROM %s" % (out_map, )
        p2 = grass.feed_command('db.execute', input='-', quiet=True)
        p2.stdin.write(sql) # Delete old information
        p2.stdin.close()
        p2.wait()

        # Loop over new categories
        p = grass.pipe_command('v.category', input=out_map, option='print')
        for line in p.stdout:
            # echo "INSERT into ... () values (...)" | db.execute
            new_cat = line.strip()
            row[field] = new_cat
            values = [str(row[f]) for f in fields]
            values = ', '.join(values)

            sql = "INSERT INTO %s (%s) VALUES (%s)" % (out_map, ','.join(fields), values)
            p2 = grass.feed_command('db.execute', input='-', quiet=True)
            p2.stdin.write(sql)
            p2.stdin.close()
            p2.wait()
        p.wait()


if __name__ == "__main__":
    options, flags = grass.parser()
    main(options, flags)
    sys.exit(0)

